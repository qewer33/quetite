# this example implements a fully functional terminal snake game
# it takes advatnge of the Term object in the stdlib

obj Pos do
    init(x, y) do
        self.x = x
        self.y = y
    end

    equals(self, other) do
        return self.x == other.x and self.y == other.y
    end
end

obj Snake do
    init() do
        self.body = [Pos(10, 10)]
        self.xdir = 1
        self.ydir = 0

        # init snake with 5 sections
        for i in 0..5 do
            self.grow()
        end
    end

    head(self) do
        return self.body.last()
    end

    tail(self) do
        return self.body.first()
    end

    move(self) do
        var width = Term.size()[0]
        var height = Term.size()[1]

        var new_x = self.head().x + self.xdir
        var new_y = self.head().y + self.ydir

        # wrap snake when it hits borders
        if new_x < 0 do
            new_x = width
        else if new_x > width do
            new_x = 0
        end

        if new_y < 1 do
            new_y = height
        else if new_y > height do
            new_y = 0
        end

        # move by pushing head and removing tail
        self.body.push(Pos(new_x, new_y))
        Term.put(self.head().x, self.head().y, "█".green())
        Term.put(self.tail().x, self.tail().y, " ")
        self.body.remove(0)
    end

    grow(self) do
        # grow by pushing head
        self.body.push(Pos(self.head().x + self.xdir, self.head().y + self.ydir))
        Term.put(self.head().x, self.head().y, "█".green())
    end

    set_pos(self, pos) do
        if pos == "Up" and self.ydir != 1 do
            self.xdir = 0
            self.ydir = -1
        else if pos == "Down" and self.ydir != -1 do
            self.xdir = 0
            self.ydir = 1
        else if pos == "Right" and self.xdir != -1 do
            self.xdir = 1
            self.ydir = 0
        else if pos == "Left" and self.xdir != 1 do
            self.xdir = -1
            self.ydir = 0
        end
    end

    check_collision(self) do
        # check if head collides with any other section
        for p, i in self.body do
            if i == self.body.len()-1 continue
            if self.head().equals(p) return true
        end

        return false
    end
end

obj Game do
    init() do
        self.snake = Snake()
        self.fruits = []
        self.game_speed = 1
        self.score = 0
    end

    run(self) do
        # configure terminal
        Term.raw_enable()
        Term.cursor_hide()
        Term.clear()

        Term.put(0, 0, " ".repeat(Term.size()[0]).on_blue())
        Term.put(0, 0, "Score: ".white().on_blue().bold())
        Term.put(7, 0, self.score.to_str().white().on_blue())

        # init 5 fruit
        for i in 0..10 do
            self.spawn_fruit()
        end

        # game logic timer
        var tprev = Sys.clock()

        while true do
            # read input
            var input = Term.get_input()
            if input do
                var key = input.key()

                if key == "Esc" break

                if ["Up", "Down", "Left", "Right"].contains(key) do
                    self.snake.set_pos(key)
                end
            end

            # game logic
            if Sys.clock()-tprev > 250/self.game_speed do
                tprev = Sys.clock()

                # check game end (snake collision)
                if self.snake.check_collision() break

                # move snake
                self.snake.move()

                # eat fruit
                for fruit, i in self.fruits do
                    if self.snake.head().equals(fruit) do
                        self.fruits.remove(i)
                        self.snake.grow()
                        self.spawn_fruit()
                        self.game_speed += 0.05
                        self.score++
                        Term.put(7, 0, self.score.to_str().white().on_blue())
                    end
                end
            end

            # delay to stabilize input
            Sys.sleep(17)
        end

        # restore terminal
        Term.cursor_show()
        Term.raw_disable()

        # print game over message
        Term.clear()
        println(" Game Over! ".red().reverse().blink())
        print("Score: ".blue())
        println(self.score)
    end

    spawn_fruit(self) do
        var width = Term.size()[0]
        var height = Term.size()[1]-2

        var x = (width*Rand.num()).round()
        var y = 1+(height*Rand.num()).round()

        self.fruits.push(Pos(x, y))
        Term.put(x, y, "⬤".red())
    end
end

# run game
var game = Game()
game.run()
